import { InventoryItem } from "@/context/InventoryContext";
import { OrderItem, POItem } from "@/context/OrdersContext";
import { Vendor } from "@/context/VendorContext";
import { showSuccess, showError } from "@/utils/toast";
import { generateSequentialNumber } from "@/utils/numberGenerator";
import { AppNotification } from "@/context/NotificationContext"; // Import AppNotification type

// Simple debounce to prevent multiple orders for the same item in a short period
const lastReorderAttempt: { [itemId: string]: number } = {};
const REORDER_DEBOUNCE_MS = 24 * 60 * 60 * 1000; // 24 hours

export const processAutoReorder = async (
  inventoryItems: InventoryItem[],
  addOrder: (order: Omit<OrderItem, "id" | "organizationId">) => Promise<void>, // Updated addOrder type
  vendors: Vendor[],
  organizationId: string | null,
  addNotification: (message: string, type?: AppNotification['type']) => void // NEW: addNotification passed as argument
) => {
  // Check global auto-reorder setting
  const isAutoReorderGloballyEnabled = typeof window !== 'undefined' 
    ? localStorage.getItem("enableAutoReorder") === "true" 
    : false;

  if (!isAutoReorderGloballyEnabled) {
    // console.log("[Auto-Reorder] Globally disabled. Skipping check.");
    return;
  }

  if (!organizationId) {
    console.warn("Cannot process auto-reorder: No organization ID available.");
    return;
  }

  const itemsToReorder = inventoryItems.filter(item =>
    item.autoReorderEnabled &&
    item.quantity <= item.reorderLevel &&
    item.autoReorderQuantity > 0 &&
    item.vendorId // Must have a vendor to auto-reorder
  );

  for (const item of itemsToReorder) {
    const now = Date.now();
    if (lastReorderAttempt[item.id] && (now - lastReorderAttempt[item.id] < REORDER_DEBOUNCE_MS)) {
      console.log(`[Auto-Reorder] Skipping ${item.name}: already attempted recently.`);
      continue;
    }

    const vendor = vendors.find(v => v.id === item.vendorId);
    if (!vendor) {
      addNotification(`Auto-reorder failed for ${item.name}: No vendor found.`, "error"); // Use passed addNotification
      showError(`Auto-reorder failed for ${item.name}: No vendor found.`);
      continue;
    }

    const poItems: POItem[] = [{
      id: Date.now(), // Unique ID within the order
      itemName: item.name,
      quantity: item.autoReorderQuantity,
      unitPrice: item.unitCost,
      inventoryItemId: item.id,
    }];

    const newPoNumber = generateSequentialNumber("PO");
    const totalAmount = poItems.reduce((sum, poItem) => sum + poItem.quantity * poItem.unitPrice, 0);

    const newPurchaseOrder: Omit<OrderItem, "id" | "organizationId"> = {
      // id: newPoNumber, // Removed: id is generated by addOrder
      type: "Purchase",
      customerSupplier: vendor.name,
      date: new Date().toISOString().split("T")[0],
      status: "New Order",
      totalAmount: totalAmount,
      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split("T")[0], // Due in 7 days
      itemCount: poItems.length,
      notes: `Auto-generated reorder for low stock of ${item.name}.`,
      orderType: "Wholesale",
      shippingMethod: "Standard",
      items: poItems,
      terms: "Net 30", // Default terms
    };

    try {
      await addOrder(newPurchaseOrder);
      lastReorderAttempt[item.id] = now; // Mark as attempted
      addNotification(`Auto-reorder placed for ${item.name} (PO: ${newPoNumber}).`, "success"); // Use passed addNotification
      showSuccess(`Auto-reorder placed for ${item.name} (PO: ${newPoNumber}). Email simulated to ${vendor.email || 'vendor'}.`);
      // Simulate email sending
      console.log(`Simulating email to ${vendor.email} for PO ${newPoNumber} with items:`, poItems);
    } catch (error: any) {
      addNotification(`Failed to auto-reorder ${item.name}: ${error.message}`, "error"); // Use passed addNotification
      showError(`Failed to auto-reorder ${item.name}: ${error.message}`);
    }
  }
};